<!DOCTYPE html> <html> <head> <title>WW2-themed PvP Air and Tank Game</title> <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script> <style> body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #333; } canvas { display: block; border: 1px solid #555; } #fullscreenButton, #tankButton, #airplaneButton, #playButton { position: absolute; padding: 10px 15px; font-size: 16px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; z-index: 100; } #fullscreenButton:hover, #tankButton:hover, #airplaneButton:hover, #playButton:hover { background-color: #45a049; } #tankButton { top: 40%; left: 40%; } #airplaneButton { top: 40%; left: 50%; } #playButton { top: 50%; left: 45%; display: none; } #fullscreenButton { bottom: 20px; right: 20px; } </style> </head> <body> <script> // Global image variables (uncomment and set URLs in preload) let tankHullImg, tankTurretImg, tankBulletImg, airplaneBulletImg, bombImg, airplaneImg, obstacleImg, mapBackgroundImg; function preload() { // Uncomment and replace 'URL' with actual image URLs // tankHullImg = loadImage('URL'); // For tank hull (70x36 pixels) // tankTurretImg = loadImage('URL'); // For tank turret (20x20 base + 20x5 barrel) // tankBulletImg = loadImage('URL'); // For tank bullet (5 pixels) // airplaneBulletImg = loadImage('URL'); // For airplane bullet (3 pixels) // bombImg = loadImage('URL'); // For bomb (75x37.5 pixels) // airplaneImg = loadImage('URL'); // For airplane (72x24 fuselage + 96x21.6 wings) // obstacleImg = loadImage('URL'); // For obstacle (100-200x100-200 pixels) // mapBackgroundImg = loadImage('URL'); // For map background (8000x8000 pixels) } let tank; let playerVehicle; let vehicleType; let bullets = []; let bombs = []; let obstacles = []; let cameraOffset; let cameraTargetOffset; let worldWidth = 8000; let worldHeight = 8000; let zoomLevel = 1; let targetZoom = 1; let minZoom = 1; let maxZoom = 0.2; const FIRING_RANGE_RADIUS = 2250; let gameState = "start"; let tankButton, airplaneButton, playButton; function setup() { createCanvas(800, 600); resetGame(); tankButton = createButton('Tank'); tankButton.id('tankButton'); tankButton.mousePressed(() => selectVehicle('tank')); airplaneButton = createButton('Airplane'); airplaneButton.id('airplaneButton'); airplaneButton.mousePressed(() => selectVehicle('airplane')); playButton = createButton('Play'); playButton.id('playButton'); playButton.mousePressed(startGame); let fsButton = createButton('Fullscreen'); fsButton.id('fullscreenButton'); fsButton.mousePressed(toggleFullscreen); } function resetGame() { obstacles = []; bullets = []; bombs = []; cameraOffset = createVector(0, 0); cameraTargetOffset = createVector(0, 0); zoomLevel = 1; targetZoom = 1; for (let i = 0; i < 30; i++) { let w = random(100, 200); let h = random(100, 200); let x = random(w / 2, worldWidth - w / 2); let y = random(h / 2, worldHeight - h / 2); obstacles.push(new Obstacle(x, y, w, h)); } let wallThickness = 100; obstacles.push(new Obstacle(worldWidth / 2, wallThickness / 2, worldWidth, wallThickness)); obstacles.push(new Obstacle(worldWidth / 2, worldHeight - wallThickness / 2, worldWidth, wallThickness)); obstacles.push(new Obstacle(wallThickness / 2, worldHeight / 2, wallThickness, worldHeight)); obstacles.push(new Obstacle(worldWidth - wallThickness / 2, worldHeight / 2, wallThickness, worldHeight)); } function selectVehicle(type) { vehicleType = type; playButton.style('display', 'block'); } function startGame() { gameState = "playing"; tankButton.hide(); airplaneButton.hide(); playButton.hide(); resetGame(); if (vehicleType === 'tank') { playerVehicle = new Tank(worldWidth / 2, worldHeight / 2); } else { playerVehicle = new Airplane(worldWidth / 2, worldHeight / 2); } } function draw() { if (gameState === "start") { background(100); cursor(); textAlign(CENTER); textSize(32); fill(255); text("Select Your Vehicle", width / 2, height / 3); return; } if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) { noCursor(); } else { cursor(); } background(200, 220, 170); // Placeholder for map background image // if (mapBackgroundImg) { //   push(); //   translate(width / 2, height / 2); //   scale(zoomLevel); //   translate(-cameraPos.x, -cameraPos.y); //   imageMode(CENTER); //   image(mapBackgroundImg, worldWidth / 2, worldHeight / 2, worldWidth, worldHeight); //   pop(); // } zoomLevel = lerp(zoomLevel, targetZoom, 0.1); let moveDistX = width / 10; let moveDistY = height / 10; if (keyIsDown(LEFT_ARROW)) { cameraTargetOffset.x -= moveDistX; } if (keyIsDown(RIGHT_ARROW)) { cameraTargetOffset.x += moveDistX; } if (keyIsDown(UP_ARROW)) { cameraTargetOffset.y -= moveDistY; } if (keyIsDown(DOWN_ARROW)) { cameraTargetOffset.y += moveDistY; } cameraOffset.lerp(cameraTargetOffset, 0.1); let cameraPos = playerVehicle.pos.copy(); cameraPos.add(cameraOffset); let viewWidth = width / zoomLevel; let viewHeight = height / zoomLevel; cameraPos.x = constrain(cameraPos.x, viewWidth / 2, worldWidth - viewWidth / 2); cameraPos.y = constrain(cameraPos.y, viewHeight / 2, worldHeight - viewHeight / 2); push(); translate(width / 2, height / 2); scale(zoomLevel); translate(-cameraPos.x, -cameraPos.y); push(); translate(playerVehicle.pos.x, playerVehicle.pos.y); stroke(255, 0, 0); strokeWeight(2 / zoomLevel); noFill(); ellipse(0, 0, FIRING_RANGE_RADIUS * 2, FIRING_RANGE_RADIUS * 2); noStroke(); pop(); if (vehicleType === 'tank') { playerVehicle.update(); playerVehicle.display(); } for (let obstacle of obstacles) { obstacle.display(); } for (let i = bullets.length - 1; i >= 0; i--) { bullets[i].update(); if (vehicleType === 'tank' && (bullets[i].hitsObstacle() || bullets[i].hitsFiringRange())) { bullets.splice(i, 1); continue; } if (bullets[i].offscreen()) { bullets.splice(i, 1); continue; } bullets[i].display(); } for (let i = bombs.length - 1; i >= 0; i--) { bombs[i].update(); if (bombs[i].state === 'hit' && vehicleType === 'tank' && bombs[i].hitTime === 0 && bombs[i].hitsTank(playerVehicle)) { gameState = "start"; tankButton.show(); airplaneButton.show(); return; } if (bombs[i].state === 'exploding' && bombs[i].explosionTime >= 1000) { bombs.splice(i, 1); continue; } bombs[i].display(); } if (vehicleType === 'airplane') { playerVehicle.update(); if (playerVehicle.state === 'exploding' && playerVehicle.explosionTime >= 1000) { gameState = "start"; tankButton.show(); airplaneButton.show(); return; } playerVehicle.display(); } pop(); let mousePos = createVector(mouseX, mouseY); let worldMousePos = mousePos.copy(); worldMousePos.sub(createVector(width / 2, height / 2)); worldMousePos.div(zoomLevel); worldMousePos.add(cameraPos); if (vehicleType === 'tank') { push(); translate(mouseX, mouseY); let now = millis(); let progress = (now - playerVehicle.lastShot) / playerVehicle.shotCooldown; let crosshairColor = (now - playerVehicle.lastShot >= playerVehicle.shotCooldown) ? color(0, 255, 0) : (progress >= 0.95 && progress <= 0.9944 ? color(255, 255, 255) : color(255, 165, 0)); stroke(crosshairColor); strokeWeight(2); noFill(); ellipse(0, 0, 20, 20); line(-12, 0, 12, 0); line(0, -12, 0, 12); if (now - playerVehicle.lastShot < playerVehicle.shotCooldown) { let angle = progress * TWO_PI; stroke(progress >= 0.95 && progress <= 0.9944 ? color(255, 255, 255) : color(0, 255, 0)); strokeWeight(4); arc(0, 0, 20, 20, -HALF_PI, -HALF_PI + angle); } noStroke(); pop(); let mouseDist = dist(playerVehicle.pos.x, playerVehicle.pos.y, worldMousePos.x, worldMousePos.y); let turretDir = p5.Vector.fromAngle(playerVehicle.angle + playerVehicle.turretAngle); let turretPos = playerVehicle.pos.copy().add(turretDir.mult(mouseDist)); let turretScreenPos = turretPos.copy(); turretScreenPos.sub(cameraPos); turretScreenPos.mult(zoomLevel); turretScreenPos.add(createVector(width / 2, height / 2)); push(); translate(turretScreenPos.x, turretScreenPos.y); stroke(255, 255, 255); strokeWeight(1); noFill(); ellipse(0, 0, 10, 10); line(-6, 0, 6, 0); line(0, -6, 0, 6); noStroke(); pop(); } else { let now = millis(); // Existing airplane crosshair at mouse position push(); translate(mouseX, mouseY); let progress = (now - playerVehicle.lastShot) / playerVehicle.shotCooldown; let crosshairColor = (now - playerVehicle.lastShot >= playerVehicle.shotCooldown) ? color(0, 255, 0) : (progress >= 0.95 && progress <= 0.9944 ? color(255, 255, 255) : color(255, 165, 0)); stroke(crosshairColor); strokeWeight(2); noFill(); ellipse(0, 0, 20, 20); line(-12, 0, 12, 0); line(0, -12, 0, 12); if (now - playerVehicle.lastShot < playerVehicle.shotCooldown) { let angle = progress * TWO_PI; stroke(progress >= 0.95 && progress <= 0.9944 ? color(255, 255, 255) : color(0, 255, 0)); strokeWeight(4); arc(0, 0, 20, 20, -HALF_PI, -HALF_PI + angle); } noStroke(); pop(); // Machine gun crosshair for airplane let mouseDist = dist(playerVehicle.pos.x, playerVehicle.pos.y, worldMousePos.x, worldMousePos.y); let wiggleAngle = 0; // Align with airplane heading let crosshairDir = p5.Vector.fromAngle(playerVehicle.angle + wiggleAngle); let crosshairPos = playerVehicle.pos.copy().add(crosshairDir.mult(mouseDist)); let crosshairScreenPos = crosshairPos.copy(); crosshairScreenPos.sub(cameraPos); crosshairScreenPos.mult(zoomLevel); crosshairScreenPos.add(createVector(width / 2, height / 2)); push(); translate(crosshairScreenPos.x, crosshairScreenPos.y); stroke(255, 255, 255); // Always white, like tank turret crosshair strokeWeight(1); noFill(); ellipse(0, 0, 10, 10); line(-6, 0, 6, 0); line(0, -6, 0, 6); noStroke(); pop(); } push(); translate(width - 110, 10); fill(200, 220, 170, 200); rect(0, 0, 100, 100); let mapScale = 100 / worldWidth; push(); scale(mapScale); stroke(255, 0, 0); strokeWeight(1 / mapScale); noFill(); ellipse(playerVehicle.pos.x, playerVehicle.pos.y, FIRING_RANGE_RADIUS * 2, FIRING_RANGE_RADIUS * 2); noStroke(); push(); translate(playerVehicle.pos.x, playerVehicle.pos.y); rotate(playerVehicle.angle); fill(vehicleType === 'tank' ? color(0, 255, 0) : color(0, 100, 255)); noStroke(); triangle( 0, -4 / mapScale, 10 / mapScale, 0, 0, 4 / mapScale ); pop(); for (let obstacle of obstacles) { fill(150, 100, 50); rectMode(CENTER); rect(obstacle.pos.x, obstacle.pos.y, obstacle.w, obstacle.h); } noFill(); stroke(255); strokeWeight(1 / mapScale); rect(cameraPos.x, cameraPos.y, viewWidth, viewHeight); noStroke(); pop(); pop(); } function keyPressed() { if (gameState === "start") return; if (keyCode === 67) { cameraTargetOffset.set(0, 0); } else if (keyCode === 189 || key === '-') { targetZoom -= 0.05; targetZoom = constrain(targetZoom, maxZoom, minZoom); } else if (keyCode === 187 || key === '=') { targetZoom += 0.05; targetZoom = constrain(targetZoom, maxZoom, minZoom); } else if (keyCode === 32) { if (vehicleType === 'airplane') { playerVehicle.dropBomb(); } } } function mouseWheel(event) { if (gameState === "start") return; let zoomChange = -event.delta / 1000; targetZoom += zoomChange; targetZoom = constrain(targetZoom, maxZoom, minZoom); return false; } function mousePressed() { if (gameState === "start") return; if (vehicleType === 'tank') { playerVehicle.shoot(); } } function toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.log(`Error attempting to enable fullscreen: ${err.message} (${err.name})`); }); } else { document.exitFullscreen(); } } class Tank { constructor(x, y) { this.pos = createVector(x, y); this.angle = 0; this.turretAngle = 0; this.vel = createVector(0, 0); this.angularVel = 0; this.lastShot = 0; this.shotCooldown = 4500; } update() { let accForward = 0.3; let accBackward = 0.1125; let maxSpeedForward = 15; let maxSpeedBackward = 5.625; let drag = 0.1; let maxAngularVel = 0.5236; if (keyIsDown(87)) { let force = p5.Vector.fromAngle(this.angle).mult(accForward); this.vel.add(force); } if (keyIsDown(83)) { let force = p5.Vector.fromAngle(this.angle).mult(-accBackward); this.vel.add(force); } if (keyIsDown(65)) { this.angularVel -= 0.01; } if (keyIsDown(68)) { this.angularVel += 0.01; } this.angularVel = constrain(this.angularVel, -maxAngularVel / frameRate(), maxAngularVel / frameRate()); let velMag = this.vel.mag(); let maxSpeed = keyIsDown(83) ? maxSpeedBackward : maxSpeedForward; if (velMag > maxSpeed) { this.vel.setMag(maxSpeed); } this.vel.mult(1 - drag); this.angularVel *= 0.9; let oldPos = this.pos.copy(); this.pos.add(this.vel); this.angle += this.angularVel; for (let obstacle of obstacles) { if (this.collidesWith(obstacle)) { this.pos = oldPos; this.vel.set(0, 0); break; } } this.pos.x = constrain(this.pos.x, 0, worldWidth); this.pos.y = constrain(this.pos.y, 0, worldHeight); let cameraPos = createVector(this.pos.x + cameraOffset.x, this.pos.y + cameraOffset.y); let mousePos = createVector(mouseX, mouseY); mousePos.sub(createVector(width / 2, height / 2)); mousePos.div(zoomLevel); mousePos.add(cameraPos); let toMouse = mousePos.sub(this.pos); let desiredAngle = toMouse.heading(); let currentAngle = this.angle + this.turretAngle; let angleDiff = atan2(sin(desiredAngle - currentAngle), cos(desiredAngle - currentAngle)); let maxTurretSpeed = 0.6109; this.turretAngle += constrain(angleDiff, -maxTurretSpeed / frameRate(), maxTurretSpeed / frameRate()); } shoot() { let now = millis(); if (now - this.lastShot > this.shotCooldown) { let turretDir = p5.Vector.fromAngle(this.angle + this.turretAngle); let turretPos = this.pos.copy().add(p5.Vector.fromAngle(this.angle).mult(10)).add(turretDir.mult(16)); bullets.push(new Bullet(turretPos, turretDir, 'tank')); this.lastShot = now; } } shotBlocked(target) { let turretPos = this.pos.copy().add(p5.Vector.fromAngle(this.angle).mult(10)).add(p5.Vector.fromAngle(this.angle + this.turretAngle).mult(16)); for (let obstacle of obstacles) { if (lineIntersectsRect(turretPos, target, obstacle)) { return true; } let obsHalfW = obstacle.w / 2; let obsHalfH = obstacle.h / 2; if (abs(target.x - obstacle.pos.x) < obsHalfW && abs(target.y - obstacle.pos.y) < obsHalfH) { return true; } } return false; } collidesWith(obstacle) { let tankHalfW = 35; let tankHalfH = 18; let obsHalfW = obstacle.w / 2; let obsHalfH = obstacle.h / 2; return (abs(this.pos.x - obstacle.pos.x) < tankHalfW + obsHalfW && abs(this.pos.y - obstacle.pos.y) < tankHalfH + obsHalfH); } display() { push(); translate(this.pos.x, this.pos.y); rotate(this.angle); // Placeholder for tank hull image // if (tankHullImg) { //   imageMode(CENTER); //   image(tankHullImg, 0, 0, 70, 36); // Replace 'URL' in preload with hull image URL // } else { fill(100, 120, 100); stroke(0, 255, 0); strokeWeight(1); rectMode(CENTER); rect(0, 0, 70, 36, 10); // } noStroke(); fill(0, 255, 0); triangle(35, -3, 35, 3, 41, 0); ellipse(41, 0, 2, 2); translate(10, 0); rotate(this.turretAngle); // Placeholder for tank turret image // if (tankTurretImg) { //   imageMode(CENTER); //   image(tankTurretImg, 0, 0, 30, 20); // Replace 'URL' in preload with turret image URL (adjust size if needed) // } else { fill(80, 100, 80); ellipse(0, 0, 20, 20); rect(15, 0, 20, 5); // } pop(); } } class Airplane { constructor(x, y) { this.pos = createVector(x, y); this.angle = 0; this.vel = p5.Vector.fromAngle(this.angle).mult(5.274); this.angularVel = 0; this.lastShot = 0; this.shotCooldown = 200; this.lastBomb = 0; this.bombCooldown = 1000; this.bombLoads = 2; this.scale = 1; this.stallTime = -1; this.state = 'flying'; this.explosionTime = 0; this.lastMousePos = createVector(mouseX, mouseY); this.mouseMoved = false; } update() { if (this.state === 'exploding') { this.explosionTime += 1000 / frameRate(); return; } let acc = 0.3; let maxSpeed = 6.153; let minSpeed = 3.516; let maxAngularVel = 0.753984; // 43.2°/s let turnSpeed = 0.753984; // 43.2°/s if (keyIsDown(87)) { this.vel.setMag(this.vel.mag() + acc); } if (keyIsDown(83)) { this.vel.setMag(max(0, this.vel.mag() - acc)); } let cameraPos = createVector(this.pos.x + cameraOffset.x, this.pos.y + cameraOffset.y); let mousePos = createVector(mouseX, mouseY); mousePos.sub(createVector(width / 2, height / 2)); mousePos.div(zoomLevel); mousePos.add(cameraPos); let toMouse = mousePos.sub(this.pos); let desiredAngle = toMouse.heading(); let angleDiff = atan2(sin(desiredAngle - this.angle), cos(desiredAngle - this.angle)); // Check if mouse has moved if (dist(mouseX, mouseY, this.lastMousePos.x, this.lastMousePos.y) > 0.1) { this.mouseMoved = true; } this.lastMousePos.set(mouseX, mouseY); // Pause turning if aligned within 1 degree and mouse hasn't moved if (abs(angleDiff) <= 0.01745 && !this.mouseMoved) { this.angle = desiredAngle; this.angularVel = 0; } else { this.angularVel += angleDiff * turnSpeed / frameRate(); this.angularVel = constrain(this.angularVel, -maxAngularVel / frameRate(), maxAngularVel / frameRate()); this.mouseMoved = false; } this.angle += this.angularVel; this.vel.setMag(constrain(this.vel.mag(), 0, maxSpeed)); this.vel = p5.Vector.fromAngle(this.angle).mult(this.vel.mag()); this.pos.add(this.vel); if (this.pos.x <= 0 || this.pos.x >= worldWidth || this.pos.y <= 0 || this.pos.y >= worldHeight) { this.state = 'exploding'; this.explosionTime = 0; return; } if (this.vel.mag() < minSpeed && this.stallTime === -1) { this.stallTime = millis(); } else if (this.vel.mag() >= minSpeed) { this.stallTime = -1; this.scale = 1; } if (this.stallTime !== -1) { let elapsed = (millis() - this.stallTime) / 2000; this.scale = constrain(1 - elapsed, 0, 1); if (this.scale === 0) { gameState = "start"; tankButton.show(); airplaneButton.show(); } } if (mouseIsPressed) { this.shoot(); } } shoot() { let now = millis(); if (now - this.lastShot > this.shotCooldown && this.state === 'flying') { let offsets = [-40, -25, 25, 40]; for (let offset of offsets) { let dir = p5.Vector.fromAngle(this.angle + random(-0.05, 0.05)); let gunPos = this.pos.copy().add(p5.Vector.fromAngle(this.angle + HALF_PI).mult(offset)); bullets.push(new Bullet(gunPos, dir, 'airplane')); } this.lastShot = now; } } dropBomb() { let now = millis(); if (now - this.lastBomb > this.bombCooldown && this.bombLoads > 0 && this.state === 'flying') { for (let i = 0; i < 2; i++) { let offsetX = random(-150, 150); let offsetY = random(-150, 150); let offset = createVector(offsetX, offsetY); offset.rotate(this.angle); let bombPos = this.pos.copy().add(offset); bombs.push(new Bomb(bombPos, this.angle)); } this.bombLoads--; this.lastBomb = now; } } display() { push(); translate(this.pos.x, this.pos.y); rotate(this.angle); scale(this.scale); if (this.state === 'flying') { // Placeholder for airplane image // if (airplaneImg) { //   imageMode(CENTER); //   image(airplaneImg, 0, 0, 96, 72); // Replace 'URL' in preload with airplane image URL (adjust size to cover fuselage + wings) // } else { fill(0, 100, 255); noStroke(); ellipse(0, 0, 24, 72); // Narrower fuselage translate(-15, 0); ellipse(0, 0, 96, 21.6); // Shorter wings // } } else if (this.state === 'exploding') { let alpha = map(this.explosionTime, 0, 1000, 255, 0); fill(255, 165, 0, alpha); noStroke(); randomSeed(this.pos.x * 1000 + this.pos.y); for (let i = 0; i < 10; i++) { let size = random(50, 100); let offsetX = random(-100, 100); let offsetY = random(-100, 100); ellipse(offsetX, offsetY, size, size); } } pop(); } } class Bullet { constructor(pos, dir, type) { this.pos = pos.copy(); this.vel = dir.copy().mult(type === 'tank' ? 3 : 20); this.type = type; } update() { this.pos.add(this.vel); } hitsObstacle() { for (let obstacle of obstacles) { let obsHalfW = obstacle.w / 2; let obsHalfH = obstacle.h / 2; if (abs(this.pos.x - obstacle.pos.x) < obsHalfW && abs(this.pos.y - obstacle.pos.y) < obsHalfH) { return true; } } return false; } hitsFiringRange() { let distToPlayer = dist(this.pos.x, this.pos.y, playerVehicle.pos.x, playerVehicle.pos.y); return distToPlayer >= FIRING_RANGE_RADIUS; } offscreen() { return this.pos.x < 0 || this.pos.x > worldWidth || this.pos.y < 0 || this.pos.y > worldHeight; } display() { push(); translate(this.pos.x, this.pos.y); if (this.type === 'tank') { // Placeholder for tank bullet image // if (tankBulletImg) { //   imageMode(CENTER); //   image(tankBulletImg, 0, 0, 5, 5); // Replace 'URL' in preload with tank bullet image URL // } else { fill(255, 0, 0); ellipse(0, 0, 5); // } } else if (this.type === 'airplane') { // Placeholder for airplane bullet image // if (airplaneBulletImg) { //   imageMode(CENTER); //   image(airplaneBulletImg, 0, 0, 3, 3); // Replace 'URL' in preload with airplane bullet image URL // } else { fill(255, 165, 0); ellipse(0, 0, 3); // } } pop(); } } class Bomb { constructor(pos, angle) { this.pos = pos.copy(); this.angle = angle; this.vel = p5.Vector.fromAngle(angle).mult(0.5); this.z = 100; this.velZ = -100 / 300; // 5-second fall this.state = 'falling'; this.hitTime = 0; this.explosionTime = 0; this.baseWidth = 75; this.baseHeight = 37.5; } update() { if (this.state === 'falling') { this.pos.add(this.vel); this.z += this.velZ; if (this.z <= 0) { this.state = 'hit'; this.z = 0; this.hitTime = 0; } } else if (this.state === 'hit') { this.hitTime += 1000 / frameRate(); if (this.hitTime >= 3000) { this.state = 'exploding'; this.explosionTime = 0; } } else if (this.state === 'exploding') { this.explosionTime += 1000 / frameRate(); } } hitsTank(tank) { let dist = p5.Vector.dist(this.pos, tank.pos); return dist < 50; } display() { push(); translate(this.pos.x, this.pos.y); rotate(this.angle); let scale = this.state === 'falling' ? 0.15 + this.z / 400 : 0.15; if (this.state === 'falling' || this.state === 'hit') { let flash = this.state === 'hit' && ( (this.hitTime >= 0 && this.hitTime < 500) || (this.hitTime >= 1000 && this.hitTime < 1500) || (this.hitTime >= 2000 && this.hitTime < 2500) ); // Placeholder for bomb image // if (bombImg && !flash) { //   imageMode(CENTER); //   image(bombImg, 0, 0, this.baseWidth * scale, this.baseHeight * scale); // Replace 'URL' in preload with bomb image URL // } else { fill(flash ? color(255, 255, 255) : color(50, 50, 50)); noStroke(); ellipse(0, 0, this.baseWidth * scale, this.baseHeight * scale); // } } else if (this.state === 'exploding') { let alpha = map(this.explosionTime, 0, 1000, 255, 0); fill(255, 165, 0, alpha); noStroke(); randomSeed(this.pos.x * 1000 + this.pos.y); for (let i = 0; i < 10; i++) { let size = random(41.67, 83.33); let offsetX = random(-100, 100); let offsetY = random(-100, 100); ellipse(offsetX, offsetY, size, size); } } pop(); } } class Obstacle { constructor(x, y, w, h) { this.pos = createVector(x, y); this.w = w; this.h = h; } display() { push(); translate(this.pos.x, this.pos.y); // Placeholder for obstacle image // if (obstacleImg) { //   imageMode(CENTER); //   image(obstacleImg, 0, 0, this.w, this.h); // Replace 'URL' in preload with obstacle image URL // } else { fill(150, 100, 50); rectMode(CENTER); rect(0, 0, this.w, this.h, 5); // } pop(); } } function lineIntersectsRect(p1, p2, rect) { let rectLeft = rect.pos.x - rect.w / 2; let rectRight = rect.pos.x + rect.w / 2; let rectTop = rect.pos.y - rect.h / 2; let rectBottom = rect.pos.y + rect.h / 2; let minX = min(p1.x, p2.x); let maxX = max(p1.x, p2.x); let minY = min(p1.y, p2.y); let maxY = max(p1.y, p2.y); if (maxX < rectLeft || minX > rectRight || maxY < rectTop || minY > rectBottom) { return false; } let lineDir = p2.copy().sub(p1); let tNear = -Infinity; let tFar = Infinity; if (lineDir.x !== 0) { let tx1 = (rectLeft - p1.x) / lineDir.x; let tx2 = (rectRight - p1.x) / lineDir.x; tNear = max(tNear, min(tx1, tx2)); tFar = min(tFar, max(tx1, tx2)); } else if (p1.x < rectLeft || p1.x > rectRight) { return false; } if (lineDir.y !== 0) { let ty1 = (rectTop - p1.y) / lineDir.y; let ty2 = (rectBottom - p1.y) / lineDir.y; tNear = max(tNear, min(ty1, ty2)); tFar = min(tFar, max(ty1, ty2)); } else if (p1.y < rectTop || p1.y > rectBottom) { return false; } return tNear <= tFar && tNear >= 0 && tFar <= 1; } </script> </body> </html>
